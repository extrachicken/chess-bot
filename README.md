# ChessPolicyNet: Сверточная нейронная сеть для предсказания шахматных ходов

`ChessPolicyNet` — это глубокая сверточная нейронная сеть, разработанная на основе PyTorch для предсказания следующего хода в шахматной партии на основе текущей позиции на доске. Модель оптимизирована для эффективного использования времени и памяти, поддерживает ленивую загрузку данных, обучение по частям (чанкам), дообучение, раннюю остановку и логирование прогресса. Проект предназначен для работы с большими наборами шахматных данных и может быть адаптирован для различных задач, связанных с анализом шахматных позиций.

## Архитектура модели

`ChessPolicyNet` представляет собой сверточную нейронную сеть, состоящую из следующих компонентов:

- **Входные данные**: Шахматные позиции, представленные в виде тензоров формы (N, 110, 8, 8), где N — количество позиций, а 110 каналов кодируют особенности доски (например, типы фигур, право на рокировку, сторона хода и т.д.).
- **Сверточные слои**:
  - `conv1`: 110 входных каналов, 128 выходных каналов, размер ядра 3, отступ (padding) 1.
  - `conv2`: 128 входных каналов, 128 выходных каналов, размер ядра 3, отступ 1.
  - `conv3`: 128 входных каналов, 256 выходных каналов, размер ядра 3, отступ 1.
  Каждый сверточный слой сопровождается функцией активации ReLU.
- **Полносвязный слой**:
  - Вход: Выпрямленный (flattened) выход сверточных слоев (256 * 8 * 8).
  - Выход: Количество классов, соответствующее числу уникальных ходов в датасете.
- **Выход**: Вероятностное распределение по возможным ходам, из которого выбирается ход с наибольшей вероятностью.

Модель реализована в классе `ChessPolicyNet`, который наследуется от `nn.Module` в PyTorch.

## Подготовка данных

Датасет для обучения `ChessPolicyNet` должен быть подготовлен в виде файлов .npz, каждый из которых содержит:
- **x**: Массив numpy формы (N, 110, 8, 8), представляющий N шахматных позиций.
- **y**: Массив numpy формы (N,), содержащий индексы ходов, соответствующие каждой позиции.

**Важно**: Датасет не включён в репозиторий из-за ограничений по размеру. В репозитории есть файл-пример одного батча. Пользователи должны самостоятельно подготовить данные, следуя указанному формату. Кодирование 110 каналов должно быть совместимо с тем, что использовалось при обучении модели. Обычно это включает:
- Плоскости для каждого типа фигур (пешки, кони, слоны, ладьи, ферзи, короли) для белых и чёрных.
- Плоскости для стороны хода, прав на рокировку, возможности взятия на проходе и других особенностей игры.

Для подготовки данных:
1. Соберите шахматные партии, например, в формате PGN.
2. Преобразуйте партии в позиции и соответствующие ходы, закодировав позиции в формате (N, 110, 8, 8).
3. Разделите данные на чанки и сохраните их в файлы .npz с ключами `x` и `y`.

**Примечание**: Для создания такого датасета можно использовать библиотеки, такие как `python-chess`, для обработки PGN-файлов и преобразования позиций в тензоры.

## Загрузка данных

Проект использует пользовательский класс `ChessNPZDataset`, который наследуется от `torch.utils.data.Dataset`. Этот класс обеспечивает ленивую загрузку данных, загружая .npz файлы в память только по мере необходимости, что снижает потребление памяти при работе с большими датасетами.

Ключевые особенности загрузки данных:
- **Ленивая загрузка**: Файлы .npz кэшируются в памяти только при первом обращении.
- **Карта меток**: Создаётся словарь `label2new`, который отображает исходные метки ходов в непрерывный диапазон индексов, начиная с 0. Это необходимо для корректной работы функции потерь CrossEntropyLoss. Карта сохраняется в файл `label_map.json` и загружается при необходимости.
- **Эффективность**: Используется `DataLoader` с параметрами `num_workers=2` и `pin_memory=True` для ускорения загрузки данных, особенно при использовании GPU.

## Обучение

Обучение модели выполняется по частям (чанкам), что позволяет обрабатывать большие датасеты, не загружая их полностью в память. Основные аспекты процесса обучения:
- **Чанки**: Датасет делится на группы по `FILES_PER_CHUNK` файлов .npz. Каждый чанк обрабатывается отдельно.
- **Поколения**: Для каждого чанка модель обучается в течение `EPOCHS_PER_CHUNK` поколений.
- **Оптимизатор**: Adam с начальной скоростью обучения 1e-4.
- **Функция потерь**: CrossEntropyLoss, подходящая для задачи многоклассовой классификации.
- **Ранняя остановка**: Если точность на текущем чанке не улучшается в течение `PATIENCE` чанков, обучение останавливается.
- **Контрольные точки**: После каждого чанка сохраняется состояние модели, оптимизатора и текущая точность в файл `checkpoint.pt`. Лучшая модель сохраняется в `best_model.pt`.
- **Логирование**: Прогресс обучения, включая время выполнения эпохи и точность, выводится в консоль.

Обучение можно возобновить с сохранённой контрольной точки, установив параметр `resume_training = True`.

## Использование модели

После обучения модель может быть использована для предсказания ходов на новых шахматных позициях. Для этого необходимо:
1. Загрузить карту меток из файла `label_map.json`.
2. Загрузить лучшую модель из файла `best_model.pt`.
3. Подготовить новую позицию в формате тензора формы (1, 110, 8, 8).
4. Выполнить предсказание и преобразовать результат в исходную метку хода.

Пример кода для предсказания:

```python
import json
import torch
from chess_ML_v1.0 import ChessPolicyNet

# Загрузка карты меток
with open("label_map.json", "r") as f:
    label2new = json.load(f)
    label2new = {int(k): int(v) for k, v in label2new.items()}
new2label = {v: k for k, v in label2new.items()}

# Загрузка модели
num_classes = len(label2new)
model = ChessPolicyNet(in_channels=110, num_classes=num_classes)
model.load_state_dict(torch.load("best_model.pt"))
model.to(torch.device("cuda" if torch.cuda.is_available() else "cpu"))
model.eval()

# Подготовка новой позиции (x_new: тензор формы (1, 110, 8, 8))
x_new = ...  # Ваша новая шахматная позиция
with torch.no_grad():
    logits = model(x_new.to(model.device))
    predicted_move_new = logits.argmax(dim=1).item()
    original_move = new2label[predicted_move_new]
    print(f"Предсказанный ход: {original_move}")
```

## Требования

Для работы проекта необходимы следующие библиотеки:
- **PyTorch**: Для построения и обучения модели.
- **NumPy**: Для работы с массивами данных.
- **JSON**: Для сохранения и загрузки карты меток.

Убедитесь, что версии библиотек совместимы. Рекомендуется использовать Python 3.7 или выше.

## Структура проекта

| Файл/Папка          | Описание                                                                 |
|---------------------|--------------------------------------------------------------------------|
| `chess_ML_v1.0.py`  | Основной скрипт, содержащий определение модели, загрузку данных и обучение. |
| `batches/`          | Папка для хранения файлов .npz (не включена в репозиторий).              |
| `checkpoint.pt`     | Файл контрольной точки для возобновления обучения.                       |
| `best_model.pt`     | Лучшая модель, сохранённая на основе максимальной точности.              |
| `label_map.json`    | Файл с картой меток для преобразования индексов ходов.                   |

## Примечания

- Скрипт изначально разработан для работы в среде Google Colab, где файлы .npz находятся в папке `/content/batches/`. Для локального использования необходимо изменить путь к файлам в коде.
- Убедитесь, что кодирование входных данных (110 каналов) соответствует используемому в обучающем наборе данных.
- Для подготовки датасета можно использовать библиотеки, такие как `python-chess`, для обработки шахматных партий и преобразования их в требуемый формат.

